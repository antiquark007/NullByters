#!/usr/bin/env python3
import os
import subprocess
import tkinter as tk
from tkinter import messagebox, simpledialog, ttk
import threading
import time
import uuid
import json
import sys
from datetime import datetime

def run_cmd(command, capture_output=True):
    try:
        result = subprocess.run(command, shell=True, capture_output=capture_output, text=True)
        if result.returncode != 0:
            return None
        return result.stdout.strip()
    except Exception:
        return None

def check_dependency(cmd):
    return run_cmd(f"which {cmd}") is not None

def show_error(msg):
    messagebox.showerror("Error", msg)
    sys.exit(1)

def wipe_android():
    required_tools = ["adb", "fastboot"]
    for tool in required_tools:
        if not check_dependency(tool):
            show_error(f"'{tool}' is not installed or not in PATH.")

    run_cmd("adb start-server")
    time.sleep(1)

    device_id = run_cmd("adb get-serialno")
    if device_id in ["unknown", None, ""]:
        show_error("No Android device detected.\nPlease connect a device with USB debugging(dev options) enabled and authorize it.")

    device_model = run_cmd("adb shell getprop ro.product.model") or "Unknown"
    device_manu = run_cmd("adb shell getprop ro.product.manufacturer") or "Unknown"
    lock_state = run_cmd("adb shell getprop ro.boot.verifiedbootstate") or "unknown"

    if lock_state.strip() == "green":
        show_error(
            f"Device: {device_manu} {device_model}\n\n"
            "Bootloader is LOCKED.\n"
            "This device CANNOT be securely wiped using fastboot.\n\n"
            "Please unlock the bootloader (if possible) or use a supported device."
        )

    proceed = messagebox.askyesno("Confirm Wipe", f"Device detected:\n{device_manu} {device_model}\n\nProceed to WIPE ALL user data?")
    if not proceed:
        messagebox.showinfo("Cancelled", "Operation cancelled.")
        sys.exit(0)

    messagebox.showinfo("Rebooting", "Device will reboot to fastboot mode...")
    run_cmd("adb reboot bootloader")

    messagebox.showinfo("Please Wait", "Waiting for device to enter fastboot mode...\n(Max 5 minutes)")
    max_wait = 300
    elapsed = 0
    fastboot_id = None

    while elapsed < max_wait:
        output = run_cmd("fastboot devices")
        if output:
            fastboot_id = output.split()[0]
            break
        time.sleep(1)
        elapsed += 1

    if not fastboot_id:
        show_error("Timed out waiting for device to enter fastboot mode.\nPlease check your connection.")

    messagebox.showinfo("Wiping", "Wiping userdata partition...")
    run_cmd(f"fastboot -s {fastboot_id} erase userdata")

    messagebox.showinfo("Wiping", "Wiping cache partition...")
    run_cmd(f"fastboot -s {fastboot_id} erase cache")

    reboot = messagebox.askyesno("Done", "Wipe complete.\n\nDo you want to reboot the device now?")
    if reboot:
        run_cmd(f"fastboot -s {fastboot_id} reboot")
    else:
        messagebox.showinfo("Manual Reboot", "Device left in fastboot mode.\nYou can manually reboot with:\nfastboot reboot")

def run_command(cmd, log_path, stop_event):
    with open(log_path, "w") as logfile:
        proc = subprocess.Popen(cmd, shell=True, stdout=logfile, stderr=logfile)
        while proc.poll() is None:
            if stop_event.is_set():
                proc.terminate()
                return False
            time.sleep(0.5)
    return proc.returncode == 0

def list_devices():
    output = subprocess.getoutput("lsblk -dpno NAME,SIZE,MODEL | grep -v 'loop\\|sr0'")
    devices = []
    for line in output.splitlines():
        parts = line.split()
        if len(parts) >= 2:
            dev = parts[0]
            info = ' '.join(parts[1:])
            devices.append((dev, info))
    return devices

def verify_wipe(device):
    try:
        data = subprocess.check_output(f"dd if={device} bs=512 count=1 status=none", shell=True)
        return all(b == 0 for b in data)
    except Exception:
        return False

def write_certificate(device, method, log_file, status, verified_clean, cert_dir="/var/log/NullBytes"):
    try:
        os.makedirs(cert_dir, exist_ok=True)
    except PermissionError:
        cert_dir = "/tmp/NullBytes"
        os.makedirs(cert_dir, exist_ok=True)

    cert = {
        "uuid": str(uuid.uuid4()),
        "device": device,
        "method": method,
        "timestamp": datetime.now().isoformat(),
        "status": status,
        "log_file": log_file,
        "verified_clean": verified_clean
    }

    filename = f"{cert['uuid']}_{os.path.basename(device)}.json"
    filepath = os.path.join(cert_dir, filename)

    with open(filepath, 'w') as f:
        json.dump(cert, f, indent=4)

    return filepath

class WipeApp:
    def __init__(self):
        self.root = tk.Tk()
        self.root.withdraw()

    def show_progress(self, stop_event):
        self.progress_win = tk.Toplevel()
        self.progress_win.title("Wiping in Progress...")
        self.progress_win.geometry("300x100")
        self.progress_win.resizable(False, False)
        ttk.Label(self.progress_win, text="Wiping device, please wait...").pack(pady=10)
        self.progressbar = ttk.Progressbar(self.progress_win, mode='indeterminate')
        self.progressbar.pack(padx=20, pady=10, fill=tk.X)
        self.progressbar.start(10)
        self.progress_win.protocol("WM_DELETE_WINDOW", lambda: None)
        self.progress_win.update_idletasks()
        x = (self.progress_win.winfo_screenwidth() - self.progress_win.winfo_reqwidth()) // 2
        y = (self.progress_win.winfo_screenheight() - self.progress_win.winfo_reqheight()) // 2
        self.progress_win.geometry(f"+{x}+{y}")

        def check_stop():
            if stop_event.is_set():
                self.progressbar.stop()
                self.progress_win.destroy()
            else:
                self.progress_win.after(100, check_stop)
        check_stop()

    def wipe_device(self, device, method):
        stop_event = threading.Event()
        log_path = f"/tmp/wipe_{os.path.basename(device)}_{int(time.time())}.log"
        if method == "Zero Fill":
            cmd = f"dd if=/dev/zero of={device} bs=1M status=progress"
        elif method == "Random Fill":
            cmd = f"dd if=/dev/urandom of={device} bs=1M status=progress"
        elif method == "Shred + Zero":
            cmd = f"shred -v -n 3 {device} && dd if=/dev/zero of={device} bs=1M status=progress"
        else:
            messagebox.showerror("Error", "Unknown wipe method selected.")
            return None, "failed"

        thread = threading.Thread(target=run_command, args=(cmd, log_path, stop_event))
        thread.start()
        self.show_progress(stop_event)

        while thread.is_alive():
            self.root.update()
            time.sleep(0.1)

        stop_event.set()
        thread.join()
        subprocess.call("sync", shell=True)
        return log_path, "success"

    def main(self):
        devices = list_devices()
        if not devices:
            messagebox.showerror("Error", "No devices found!")
            return

        device_labels = [f"{dev} - {info}" for dev, info in devices]
        choice = simpledialog.askinteger("Select Device", "\n".join(f"{i+1}: {label}" for i, label in enumerate(device_labels)))
        if not choice or choice < 1 or choice > len(devices):
            return
        device = devices[choice - 1][0]

        mounts = subprocess.getoutput("mount")
        if device in mounts:
            messagebox.showerror("Mounted!", f"Device {device} is currently mounted. Please unmount it first.")
            return

        methods = ["Zero Fill", "Random Fill", "Shred + Zero"]
        method_index = simpledialog.askinteger("Wipe Method", f"Choose wipe method:\n1. {methods[0]}\n2. {methods[1]}\n3. {methods[2]}")
        if not method_index or method_index < 1 or method_index > 3:
            return
        method = methods[method_index - 1]

        confirm = messagebox.askyesno("CONFIRM", f"This will ERASE all data on {device} using {method}.\n\nAre you absolutely sure?")
        if not confirm:
            return

        messagebox.showinfo("Starting Wipe", f"Wiping {device} using {method}. This may take a while...")
        log_file, status = self.wipe_device(device, method)

        verified_clean = False
        if status == "success":
            verify = messagebox.askyesno("Verify", "Attempt simple verification of wipe?\n(Reads first 512 bytes)")
            if verify:
                verified_clean = verify_wipe(device)
                if verified_clean:
                    messagebox.showinfo("Verified", "First sector appears zeroed.")
                else:
                    messagebox.showwarning("Not Verified", "First sector NOT clean. Wipe may be incomplete.")
        else:
            messagebox.showerror("Wipe Failed", "The wipe process failed. See log for details.")

        cert_path = write_certificate(
            device=device,
            method=method,
            log_file=log_file,
            status=status,
            verified_clean=verified_clean
        )

        messagebox.showinfo("Done", f"Wipe complete.\n\nLog file: {log_file}\nCertificate saved at:\n{cert_path}")

def main():
    root = tk.Tk()
    root.withdraw()
    choice = simpledialog.askinteger("Select Device Type", "What do you want to wipe?\n1. Computer (Linux/Windows)\n2. Android Phone")

    if choice == 1:
        app = WipeApp()
        app.main()
    elif choice == 2:
        wipe_android()
    else:
        messagebox.showinfo("Cancelled", "No valid option selected. Exiting.")

if __name__ == "__main__":
    main()